# 기초
### 자료구조
데이터를 표현하고 관라하고 처리하기 위한 구조

### 탐색
많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
대표적인 탐색 알고리즘 'DFS' , 'BFS'

<br>

### 스택 (리스트 이용, 원소 제거는 pop())
후입선출(LIFO, Last In First Out) 구조이며 프링글스를 생각

```python
# 스택 예제 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
stack =[]

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack) # 최하단 원소부터 출력 [5,2,3,1]
print(stack[::-1]) # 최상단 원소부터 출력 [1,3,2,5]
```
스택의 경우 별도 라이브러리를 사용할 필요 없이 기본 리스트에 append(), pop() 메서드를 이용하면 됨

<br>

### 큐 (from collections import deque 이용, 원소 제거는 popleft())
선입선출(FIFO, First In First Out) 구조이며 놀이공원에 입장하기 위한 대기줄을 생각

```python
# 큐 예제 삽입(5)-삽입(2)-삽입(3)-삽입(7)-삭제()-삽입(1)-삽입(4)-삭제()
# 큐 구현을 위해 deque 라이브러리를 사용
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
# 큐는 선입선출이므로 가장 왼쪽에 있는 값(index[0])을 pop 해야 함
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력 deque([3,7,1,4])
queue.reverse() # 다음 출력을 위해 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력 deque([4,1,7,3])
```
큐를 구현할 때는 collections 모듈에서 제공하는 deque(덱) 자료구조를 활용하면 됨
deque 객체를 리스트 자료형으로 변경하려면 list(deque)하면 됨

<br>

### 재귀 함수 (내부적으로 스택 자료구조와 동일)
자기자신을 다시 호출하는 함수로 DFS와 BFS를 구현하려면 이해하고 있어야 함
재귀 함수를 사용할 때는 언제 끝날지, 종료 조건을 꼭 명시해야 함

```python
# 재귀 함수 종료 예제
def recursive_function(i):
    # 10번째 출력했을 때 종료되도록 종료 조건 명시
    if i == 10:
        return
    print(f'{i}번째 재귀 함수에서 {i+1}번째 재귀 함수를 호출합니다.')
    recursive_function(i+1)
    print(f'{i}번째 재귀 함수를 종료합니다.')
    
recursive_function(1)
```
컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용하는데 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문임

<br>

<b>반복문 vs 재귀 함수</b>
<br>
https://wonillism.tistory.com/17
여기 링크 참조
<br>

```python
# 팩토리얼 예제 반복문 vs 재귀 함수
# 반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    # 1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n+1):
        result *= i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):
    # n이 1 이하인 경우 1을 반환
    if n <= 1:
        return 1
    # n! = n * (n-1)!를 그대로 코드로 작성하기
    return n * factorial_recursive(n-1)

print(f'반복적으로 구현 : {factorial_iterative(5)}')
print(f'재귀적으로 구현 : {factorial_recursive(5)}')
```
반복문 대신 재귀 함수를 사용하면 코득 간결해진다는 장점이 있는데 이유는 재귀 함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문임
이는 추후에 다이나믹 프로그래밍에서 필요한 개념임
   
<br>



